<!-- /me310/2.32.html -->
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Constant-Pressure Surfaces in a Liquid Undergoing Rigid-Body Rotation</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <link rel="stylesheet" href="../styles.css" />
  <script src="https://d3js.org/d3.v7.min.js"></script>

  <!-- MathJax -->
  <script>
    window.MathJax = { chtml:{scale:0.9}, options:{renderActions:{addMenu:[]}} };
  </script>
  <script defer src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>

  <style>
    .site-header .container{padding-top:20px;padding-bottom:20px}
    .header-row{display:flex;align-items:center;justify-content:space-between;gap:14px;flex-wrap:wrap}
    .btn{display:inline-flex;align-items:center;gap:8px;padding:10px 14px;border-radius:10px;border:1px solid #ffffff55;
         background:rgba(255,255,255,.12);color:#fff;text-decoration:none}
    .btn.primary{background:var(--accent);border-color:transparent}
    .btn.primary:hover{filter:brightness(1.06)}

    .back-row{display:flex;align-items:center;margin:12px 0 14px}
    .back-home{
      display:inline-flex;align-items:center;gap:6px;
      padding:6px 10px;border:1px solid var(--line);border-radius:999px;
      background:#fff;color:#0ea5e9;text-decoration:none;font-size:14px;
    }
    .back-home:hover{background:#f0f9ff}
    .back-home .chev{font-size:16px;line-height:1}

    /* Layout: derivation + schematic */
    .top-grid{display:grid;gap:14px;margin-top:10px}
    .side-col{display:flex;flex-direction:column;gap:12px}
    @media (min-width:900px){
      .top-grid{
        grid-template-columns:minmax(0,2.1fr) minmax(260px,0.9fr);
        align-items:flex-start;
      }
      .side-col{
        position:sticky;
        top:96px;
        align-self:flex-start;
      }
    }

    .eqwrap{margin-bottom:10px}
    .eqwrap p{margin:4px 0}
    .note{font-size:14px;color:#4b5563}

    .schematic-card p{margin:0 0 6px;font-size:14px;color:#4b5563}
    .schematic-img-wrap{display:flex;justify-content:center;align-items:center;margin-top:6px;margin-bottom:4px}
    .schematic-img{display:block;max-width:260px;width:100%;height:auto;object-fit:contain}

    /* ===== Kill scrollbars on cards (override styles.css) ===== */
    .card{
      max-height:none !important;
      height:auto !important;
      overflow:visible !important;
    }
    .card *{
      overflow:visible !important;
    }

    /* Inputs card (full width) */
    .inputs-card{margin-top:18px}
    .inputs-card h2{margin:4px 0 10px}
    .inputs-grid{
      display:grid;
      gap:14px;
      grid-template-columns:repeat(auto-fit,minmax(260px,1fr));
    }
    .inputs-grid .ctl{display:flex;flex-direction:column;gap:6px}
    .inputs-grid label{font-size:13px;color:#4b5563}
    .ctl-row{display:flex;gap:8px;align-items:center}
    .ctl-row input[type="range"]{flex:1}
    .ctl-row input[type="number"]{
      width:90px;max-width:100%;padding:6px 8px;
      border:1px solid var(--line);border-radius:8px;
    }

    /* Plots wrapper */
    .plots-wrapper{margin-top:12px}
    .plots-grid{
      display:grid;gap:14px;margin-top:10px;
      grid-template-columns:repeat(auto-fit,minmax(260px,1fr));
    }
    .plot-panel{display:flex;flex-direction:column}

    .viz{background:#fff;border:1px solid var(--line);border-radius:12px;padding:8px}
    #plot-omega,#plot-radius,#plot-depth{width:100%;height:auto;display:block}

    .legend-block{margin-top:6px}
    .legend-row{margin-bottom:4px}
    .legend-item{display:inline-flex;align-items:center;gap:6px;margin-right:12px;font-size:13px;color:#334155}
    .legend-item .sw{display:inline-block;width:14px;height:14px;border-radius:3px;border:1px solid #0002}
    .legend-block .dim-note{font-size:13px;color:#6b7280;margin:0;line-height:1.4}

    svg .axis text{font-size:14px}
    svg .axis-title{font-size:16px}
  </style>
</head>

<body>
  <!-- Header -->
  <header class="site-header">
    <div class="container">
      <div class="header-row">
        <div>
          <h1 style="margin:0">Constant-Pressure Surfaces in a Liquid Undergoing Rigid-Body Rotation</h1>
          <p class="subtitle">Visualize how the free-surface shape depends on angular velocity, tank radius, and liquid depth.</p>
        </div>
        <a class="btn primary feedback-link" href="../feedback.html" target="_blank" rel="noopener">Send feedback</a>
      </div>
    </div>
  </header>

  <main class="container">
    <nav class="back-row">
      <a href="../index.html" class="back-home" aria-label="Back to home">
        <span class="chev">‚Üê</span> Home
      </a>
    </nav>

    <!-- Derivation + schematic -->
    <section class="top-grid">
      <div class="card">
        <h2 style="margin:4px 0 8px">Liquid in Rigid-Body Rotation</h2>

        <div class="eqwrap">
          <p class="note">
            Consider a liquid in a container with circular cross section operating in rigid-body rotation
            with angular velocity \( \omega \) about the vertical \( z \)-axis.
          </p>
          <p class="note">
            <b>Equation for surfaces of constant pressure</b><br>
            (The free surface is a representative constant-pressure surface of the liquid in rigid-body rotation.)
          </p>
          \[
            z = \frac{\omega^2 r^2}{2g} + \text{constant}.
          \]
          <p class="note">
            The constant in the above equation depends on the setup of the \( z \)-coordinate and is also
            a function of geometry and angular velocity. For a given setup of the \( z \)-coordinate, geometry,
            and angular velocity, different values of this constant correspond to different free-surface profiles.
          </p>
        </div>

        <div class="eqwrap">
          <p style="margin:0 0 4px"><b>Constant volume (no spilling)</b></p>
          <p class="note">
            Let the container have radius \( R \) and liquid depth \( H \) when \( \omega = 0 \)
            (so \( H \) is the liquid depth at rest).
            The volume at rest is
          </p>
          \[
            V = \pi R^2 H.
          \]
          <p class="note">
            When rotating at \( \omega \), with the free surface written as
          </p>
          \[
            h = \frac{\omega^2 r^2}{2g} + h_0,
          \]
          <p class="note">
            the volume of liquid is
          </p>
          \[
            \begin{aligned}
              V &= \int_0^R 2\pi r\,h\,dr
                 = \int_0^R 2\pi r\left(\frac{\omega^2 r^2}{2g} + h_0\right)dr \\
                &= 2\pi \left[\frac{\omega^2}{2g}\int_0^R r^3\,dr
                             + h_0\int_0^R r\,dr\right] \\
                &= \frac{\pi \omega^2 R^4}{4g} + \pi R^2 h_0.
            \end{aligned}
          \]
          <p class="note">
            Equating the two expressions for \( V \) gives
          </p>
          \[
            \pi R^2 H
              = \frac{\pi \omega^2 R^4}{4g} + \pi R^2 h_0
              \quad\Rightarrow\quad
              h_0 = H - \frac{\omega^2 R^2}{4g}.
          \]
        </div>

        <div class="eqwrap">
          <p style="margin:0 0 4px"><b>Free-surface equation</b></p>
          <p class="note">
            Substituting \( h_0 \) back into \( h \) gives the free-surface profile
            for a cylindrical container (no spilling):
          </p>
          \[
            z = h
                  = \frac{\omega^2 r^2}{2g}
                    + H - \frac{\omega^2 R^2}{4g}.
          \]
          <p class="note">
            Here \( H \) is the liquid depth when the tank is at rest.
            Different choices of \( \omega \), \( R \), and \( H \) lead to different free-surface profiles.
          </p>
        </div>
      </div>

      <div class="side-col">
        <div class="card schematic-card">
          <h2 style="margin:4px 0 8px">Schematic</h2>
          <p>
            Vertical cylindrical container of radius \( R \) rotating at angular velocity \( \omega \).
            The bottom is at \( z = 0 \); the initial liquid depth at rest is \( H \).
          </p>
          <div class="schematic-img-wrap">
            <img src="../assets/thumbs/2.32.png" alt="Rigid-body rotation schematic" class="schematic-img" />
          </div>
          <p>
            During rotation, the free surface \( z \) becomes parabolic. The depth at the center is
            \( h_0 = H - \dfrac{\omega^2 R^2}{4g} \), and the elevation at the wall is
            \( z(R) = H + \dfrac{\omega^2 R^2}{4g} \).
          </p>
        </div>
      </div>
    </section>

    <!-- Inputs -->
    <section class="card inputs-card">
      <h2>Inputs</h2>
      <div class="inputs-grid">
        <div class="ctl">
          <label for="omegaSlider">Angular velocity \( \omega \) (rad/s)</label>
          <div class="ctl-row">
            <input id="omegaSlider" type="range" min="0" max="10" step="0.1" value="8">
            <input id="omegaInput" type="number" min="0" max="10" step="0.1" value="8">
          </div>
        </div>
        <div class="ctl">
          <label for="RSlider">Cylinder radius \( R \) (m)</label>
          <div class="ctl-row">
            <input id="RSlider" type="range" min="0.1" max="0.5" step="0.01" value="0.40">
            <input id="RInput" type="number" min="0.1" max="0.5" step="0.01" value="0.40">
          </div>
        </div>
        <div class="ctl">
          <label for="HSlider">Liquid depth at rest (i.e. \( \omega = 0 \)), \( H \) (m)</label>
          <div class="ctl-row">
            <input id="HSlider" type="range" min="0.7" max="1.3" step="0.01" value="1.0">
            <input id="HInput" type="number" min="0.7" max="1.3" step="0.01" value="1.0">
          </div>
        </div>
      </div>
      <p class="note" style="margin-top:10px">
        These values are used to generate three families of free-surface profiles: one varying \( \omega \),
        one varying \( R \), and one varying \( H \).
      </p>
    </section>

    <!-- Plots -->
    <section class="card plots-wrapper">
      <h2 style="margin:4px 0 8px">Free-surface profiles \( z(r) \)</h2>
      <p class="note" style="margin-top:4px">
        The plots below show the free-surface profiles \( z(r) \) for three different cases:
        varying angular velocity \( \omega \), varying cylinder radius \( R \), and varying liquid depth \( H \).
      </p>

      <div class="plots-grid">
        <div class="plot-panel">
          <h3 style="margin:4px 0 6px">Effect of Angular Velocity \( \omega \)</h3>
          <div class="viz">
            <svg id="plot-omega" viewBox="0 0 360 460" aria-label="Free surfaces for different angular velocities"></svg>
          </div>
          <div id="legend-omega" class="legend-block"></div>
        </div>

        <div class="plot-panel">
          <h3 style="margin:4px 0 6px">Effect of Cylinder Radius \( R \)</h3>
          <div class="viz">
            <svg id="plot-radius" viewBox="0 0 360 460" aria-label="Free surfaces for different radii"></svg>
          </div>
          <div id="legend-radius" class="legend-block"></div>
        </div>

        <div class="plot-panel">
          <h3 style="margin:4px 0 6px">Effect of Initial Depth \( H \)</h3>
          <div class="viz">
            <svg id="plot-depth" viewBox="0 0 360 460" aria-label="Free surfaces for different depths"></svg>
          </div>
          <div id="legend-depth" class="legend-block"></div>
        </div>
      </div>
    </section>
  </main>

  <script>
    const g = 9.81;
    const colors = ['#2563eb','#f97316','#10b981'];

    function clamp(val, min, max){ return Math.max(min, Math.min(max, val)); }

    // Build points for z(r); if any portion goes below z=0, cut it off at the x-axis
    function makeSurfaceClipped(omega, R, H, steps){
      const n = steps || 140;
      const h0 = H - (omega*omega*R*R)/(4*g);

      const pts = [];
      let prevR = null, prevZ = null;

      for(let i=0;i<=n;i++){
        const r = R * i/n;
        const z = (omega*omega*r*r)/(2*g) + h0;

        const prevPos = (prevZ !== null) && (prevZ >= 0);
        const currPos = (z >= 0);

        // crossing z=0: add intersection then break segment with NaN (same strategy as 2.33)
        if(prevZ !== null && prevR !== null && (prevPos !== currPos)){
          const rCross = prevR + (0 - prevZ) * (r - prevR) / (z - prevZ);
          pts.push({r:rCross, z:0});
          pts.push({r:rCross, z:NaN});
        }

        if(currPos){
          pts.push({r,z});
        }else{
          pts.push({r, z:NaN});
        }

        prevR = r;
        prevZ = z;
      }

      return {omega,R,H,h0,pts};
    }

    function buildSurfaces(mode, omega0, R0, H0){
      const surfaces = [];

      if(mode === 'omega'){
        const omegas = [omega0, 0.5*omega0, omega0/3];
        const labels = ['\\omega','\\tfrac{1}{2}\\omega','\\tfrac{1}{3}\\omega'];
        omegas.forEach((om,i)=>{
          surfaces.push({
            key:'w'+i,
            label:labels[i],
            color:colors[i],
            surface:makeSurfaceClipped(om,R0,H0)
          });
        });

      }else if(mode === 'radius'){
        const Rs = [R0, 0.5*R0, R0/3];
        const labels = ['R','\\tfrac{1}{2}R','\\tfrac{1}{3}R'];
        Rs.forEach((R,i)=>{
          surfaces.push({
            key:'r'+i,
            label:labels[i],
            color:colors[i],
            surface:makeSurfaceClipped(omega0,R,H0)
          });
        });

      }else{ // depth
        const Hs = [H0, 0.5*H0, (1/3)*H0];
        const labels = ['H','\\tfrac{1}{2}H','\\tfrac{1}{3}H'];
        Hs.forEach((H,i)=>{
          surfaces.push({
            key:'h'+i,
            label:labels[i],
            color:colors[i],
            surface:makeSurfaceClipped(omega0,R0,H)
          });
        });
      }

      return surfaces;
    }

    function initPlot(id){
      const svg = d3.select('#'+id);
      const W = 360, Hh = 460;
      const margin = {top:18,right:16,bottom:54,left:54};
      const iw = W - margin.left - margin.right;
      const ih = Hh - margin.top - margin.bottom;

      svg.attr('viewBox',`0 0 ${W} ${Hh}`);

      const gMain = svg.append('g').attr('transform',`translate(${margin.left},${margin.top})`);
      const axesG = gMain.append('g').attr('class','axes');
      const curvesG = gMain.append('g').attr('class','curves');

      const xAxisG = axesG.append('g').attr('class','axis axis--x')
        .attr('transform',`translate(0,${ih})`);
      const yAxisG = axesG.append('g').attr('class','axis axis--y');

      axesG.append('text')
        .attr('class','axis-title')
        .attr('x', iw/2)
        .attr('y', ih + 40)
        .attr('text-anchor','middle')
        .text('r (m)');

      axesG.append('text')
        .attr('class','axis-title')
        .attr('transform',`translate(-40,${ih/2}) rotate(-90)`)
        .attr('text-anchor','middle')
        .text('z (m)');

      const xScale = d3.scaleLinear().range([0,iw]);
      const yScale = d3.scaleLinear().range([ih,0]);

      const line = d3.line()
        .defined(d => Number.isFinite(d.z))
        .x(d=>xScale(d.r))
        .y(d=>yScale(d.z));

      return {svg,gMain,axesG,curvesG,xAxisG,yAxisG,xScale,yScale,line,iw,ih};
    }

    const plots = {
      omega:  initPlot('plot-omega'),
      radius: initPlot('plot-radius'),
      depth:  initPlot('plot-depth')
    };

    function updateLegend(mode, surfaces){
      const lid = (mode==='omega') ? 'legend-omega' : (mode==='radius') ? 'legend-radius' : 'legend-depth';
      const container = document.getElementById(lid);

      let explHTML;
      if(mode === 'omega'){
        explHTML =
          'All curves use the same radius \\(R\\) and depth \\(H\\); only the angular velocity \\(\\omega\\) changes. ' +
          'A dashed curve shows the flat free surface at \\(\\omega = 0\\).';
      }else if(mode === 'radius'){
        explHTML =
          'All curves use the same angular velocity \\(\\omega\\) and depth \\(H\\); only the cylinder radius \\(R\\) changes. ' +
          'A dashed curve shows the flat free surface at \\(\\omega = 0\\).';
      }else{
        explHTML =
          'All curves use the same angular velocity \\(\\omega\\) and radius \\(R\\); only the initial liquid depth \\(H\\) changes. ' +
          'Solid curves show the rotating free surface; dashed curves show the corresponding flat free surfaces at \\(\\omega = 0\\).';
      }

      const itemsHTML = surfaces.map(s =>
        `<span class="legend-item"><span class="sw" style="background:${s.color}"></span><span>\\(${s.label}\\)</span></span>`
      ).join('');

      container.innerHTML = `<div class="legend-row">${itemsHTML}</div><p class="dim-note">${explHTML}</p>`;

      if(window.MathJax && window.MathJax.typesetPromise){
        MathJax.typesetPromise([container]);
      }
    }

    function updatePlot(plotObj, mode, omega0, R0, H0){
      const surfaces = buildSurfaces(mode, omega0, R0, H0);

      // dashed reference curves for omega=0 (flat free surface)
      let zeroCurves = [];
      if(mode === 'depth'){
        // dashed line for each H level (clipped is unnecessary but keep consistent)
        zeroCurves = surfaces.map((s, idx)=>{
          const R = s.surface.R;
          const H = s.surface.H;
          const n = 140;
          const pts = [];
          for(let i=0;i<=n;i++){
            const r = R * i/n;
            pts.push({r, z: H}); // always >=0 in allowed slider range
          }
          return {key:'z'+idx, color:s.color, pts};
        });
      }else{
        const Rref = surfaces[0].surface.R;
        const Href = surfaces[0].surface.H;
        const n = 140;
        const pts = [];
        for(let i=0;i<=n;i++){
          const r = Rref * i/n;
          pts.push({r, z: Href});
        }
        zeroCurves = [{key:mode+'-z0', color:'#6b7280', pts}];
      }

      // x domain to largest radius in set
      let rMax = 0;
      surfaces.forEach(s => { if(s.surface.R > rMax) rMax = s.surface.R; });
      plotObj.xScale.domain([0, rMax]);

      // y domain: start at 0 (x-axis), top fixed to 2 like your original
      plotObj.yScale.domain([0, 2]);

      plotObj.xAxisG.call(d3.axisBottom(plotObj.xScale).ticks(5));
      plotObj.yAxisG.call(d3.axisLeft(plotObj.yScale).ticks(5));

      // solid rotating curves
      const paths = plotObj.curvesG.selectAll('path.curve')
        .data(surfaces, d=>d.key);

      paths.enter()
        .append('path')
        .attr('class','curve')
        .attr('fill','none')
        .attr('stroke-width',2.2)
        .merge(paths)
        .attr('stroke',d=>d.color)
        .attr('d',d=>plotObj.line(d.surface.pts));

      paths.exit().remove();

      // dashed flat curves
      const dpaths = plotObj.curvesG.selectAll('path.curve-zero')
        .data(zeroCurves, d=>d.key);

      dpaths.enter()
        .append('path')
        .attr('class','curve-zero')
        .attr('fill','none')
        .attr('stroke-width',1.8)
        .attr('stroke-dasharray','6,4')
        .merge(dpaths)
        .attr('stroke', d=>d.color)
        .attr('d', d=>plotObj.line(d.pts));

      dpaths.exit().remove();

      updateLegend(mode, surfaces);
    }

    function updateAll(){
      const OMIN=0, OMAX=10;
      const RMIN=0.1, RMAX=0.5;
      const HMIN=0.7, HMAX=1.3;

      let omega = parseFloat(document.getElementById('omegaInput').value);
      let R     = parseFloat(document.getElementById('RInput').value);
      let H     = parseFloat(document.getElementById('HInput').value);

      if(isNaN(omega)) omega = 8;
      if(isNaN(R))     R = 0.40;
      if(isNaN(H))     H = 1.0;

      omega = clamp(omega, OMIN, OMAX);
      R     = clamp(R,     RMIN, RMAX);
      H     = clamp(H,     HMIN, HMAX);

      document.getElementById('omegaInput').value = omega.toFixed(2);
      document.getElementById('RInput').value     = R.toFixed(2);
      document.getElementById('HInput').value     = H.toFixed(2);

      document.getElementById('omegaSlider').value = omega;
      document.getElementById('RSlider').value     = R;
      document.getElementById('HSlider').value     = H;

      updatePlot(plots.omega,  'omega',  omega, R, H);
      updatePlot(plots.radius, 'radius', omega, R, H);
      updatePlot(plots.depth,  'depth',  omega, R, H);
    }

    function bindInputPair(numId, sliderId){
      const num = document.getElementById(numId);
      const sld = document.getElementById(sliderId);
      num.addEventListener('input', updateAll);
      sld.addEventListener('input', function(){
        num.value = sld.value;
        updateAll();
      });
    }

    bindInputPair('omegaInput','omegaSlider');
    bindInputPair('RInput','RSlider');
    bindInputPair('HInput','HSlider');

    window.addEventListener('DOMContentLoaded', function(){
      updateAll();
      if(window.MathJax && window.MathJax.typesetPromise){
        MathJax.typesetPromise();
      }
    });
  </script>

  <!-- Feedback context -->
  <script>
    const FEEDBACK = { course: 'ME 310', sim: 'Eq 2.32 Constant-Pressure Surfaces in Rigid-Body Rotation' };
    document.addEventListener('DOMContentLoaded', function(){
      const url = new URL('../feedback.html', location.href);
      if (FEEDBACK.course) url.searchParams.set('course', FEEDBACK.course);
      if (FEEDBACK.sim)    url.searchParams.set('sim',    FEEDBACK.sim);
      document.querySelectorAll('a.feedback-link').forEach(function(a){
        a.href = url.toString();
        try { localStorage.setItem('fb_ctx', JSON.stringify(FEEDBACK)); } catch(e){}
      });
    });
  </script>
</body>
</html>
