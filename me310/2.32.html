<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>2.32 • Hydrostatic Force on a Triangular Gate</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/d3/7.9.0/d3.min.js"></script>
  <script>
    // MathJax (v3) config — render TeX on demand only
    window.MathJax = {
      tex: {inlineMath: [["$","$"], ["\\(","\\)"]]},
      svg: {fontCache: 'global'},
      options: { renderActions: { addMenu: [] } }
    };
  </script>
  <script async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.js"></script>
  <style>
    :root{
      --bg:#0b1220; --card:#0f172a; --muted:#94a3b8; --text:#e2e8f0; --accent:#60a5fa;
      --shadow:0 10px 30px rgba(0,0,0,.35);
    }
    *{box-sizing:border-box}
    body{margin:0;background:var(--bg);color:var(--text);font:16px/1.45 system-ui,Segoe UI,Roboto,Inter,Arial}
    header{padding:22px 20px 10px;position:sticky;top:0;background:linear-gradient(180deg, rgba(11,18,32,.96), rgba(11,18,32,.85) 60%, rgba(11,18,32,0));backdrop-filter:saturate(130%) blur(6px);z-index:2;border-bottom:1px solid rgba(255,255,255,.07)}
    h1{font-size:22px;margin:0 0 2px;letter-spacing:.2px}
    .sub{color:var(--muted);font-size:13px}
    .wrap{max-width:1200px;margin:0 auto;padding:16px}
    .grid{display:grid;grid-template-columns:360px 1fr;gap:16px}
    @media (max-width:980px){.grid{grid-template-columns:1fr}}
    .card{background:var(--card);border:1px solid rgba(255,255,255,.06);border-radius:16px;box-shadow:var(--shadow)}
    .card h2{font-size:16px;margin:0 0 8px}
    .card .body{padding:14px 14px 12px}
    .row{display:grid;grid-template-columns:1fr 110px;gap:10px;align-items:center;margin:10px 0}
    .row label{font-size:13px;color:var(--muted)}
    input[type="number"], select{width:100%;padding:8px 10px;border-radius:10px;border:1px solid rgba(255,255,255,.1);background:#0b1328;color:var(--text)}
    input[type="range"]{width:100%}
    .pill{display:inline-flex;gap:8px;align-items:center;background:#0b1328;border:1px solid rgba(255,255,255,.08);padding:6px 10px;border-radius:999px;color:var(--muted);font-size:12px}
    .flex{display:flex;gap:12px;align-items:center;flex-wrap:wrap}
    .two{display:grid;grid-template-columns:1fr 1fr;gap:10px}
    .mono{font-family:ui-monospace, SFMono-Regular, Menlo, Consolas, monospace}
    .eq{padding:10px 12px;border-radius:12px;background:#0b1328;border:1px solid rgba(255,255,255,.08);margin:6px 0}
    .schematic{display:flex;align-items:center;justify-content:center;padding:8px}
    .schematic svg{max-width:340px;width:100%;height:auto;display:block}
    .plotCard{padding:6px 10px 14px}
    .hint{color:var(--muted);font-size:12px}
    .divider{height:1px;background:rgba(255,255,255,.06);margin:8px 0}
    .badge{font-size:11px;background:rgba(96,165,250,.15);color:#bfdbfe;border:1px solid rgba(96,165,250,.35);padding:2px 8px;border-radius:999px}
  </style>
</head>
<body>
  <header>
    <div class="wrap">
      <h1>2.32 • Hydrostatic Force on a Triangular Gate</h1>
      <div class="sub">Interactive calculator + schematic + $(x_R-x_C)$ & $(y_R-y_C)$ plot (LaTeX renders on release).</div>
    </div>
  </header>

  <div class="wrap">
    <div class="grid">
      <!-- LEFT: Inputs & Readouts -->
      <section class="card">
        <div class="body">
          <h2>Inputs</h2>
          <div class="row">
            <label>Triangle height $a$ (m)</label>
            <input id="a" type="number" step="0.001" value="1.000" min="0.01"/>
          </div>
          <div class="row">
            <label>Base width $b$ (m)</label>
            <input id="b" type="number" step="0.001" value="1.500" min="0.01"/>
          </div>
          <div class="row">
            <label>Plate angle $\theta$ (deg)</label>
            <input id="theta" type="number" step="0.1" value="45" min="0" max="180"/>
          </div>
          <div class="row">
            <label>Reference edge</label>
            <select id="refEdge">
              <option value="top" selected>Top edge depth known</option>
              <option value="base">Base edge depth known</option>
            </select>
          </div>
          <div class="row">
            <label><span id="refLabel">Top edge depth</span> $h_{\text{ref}}$ (m)</label>
            <input id="href" type="number" step="0.001" value="0.800" min="0"/>
          </div>
          <div class="row">
            <label>Width into page $w$ (m)</label>
            <input id="w" type="number" step="0.001" value="1.000" min="0.001"/>
          </div>
          <div class="row">
            <label>Fluid density $\rho$ (kg/m$^3$)</label>
            <input id="rho" type="number" step="1" value="1000" min="1"/>
          </div>
          <div class="row">
            <label>Gravity $g$ (m/s$^2$)</label>
            <input id="g" type="number" step="0.001" value="9.81" min="0"/>
          </div>

          <div class="divider"></div>
          <div class="two">
            <div>
              <label class="hint">Depth sweep max (m)</label>
              <input id="xmax" type="number" class="mono" step="0.1" value="4.0" min="0.5"/>
            </div>
            <div>
              <label class="hint">Live update style</label>
              <select id="updateMode">
                <option value="onRelease" selected>Numbers live, LaTeX on release</option>
                <option value="instant">Everything live (may flicker)</option>
              </select>
            </div>
          </div>

          <div style="margin-top:12px" class="flex">
            <span class="pill">Area $A = \tfrac12 ab$</span>
            <span class="pill">Centroid from base $= a/3$</span>
            <span class="pill">$F_R = \rho g A h_C$</span>
            <span class="pill">$h_P = h_C + \dfrac{I_G\sin^2\!\theta}{A\,h_C}$</span>
          </div>
        </div>
      </section>

      <!-- RIGHT: Schematic + Results + Plot -->
      <section class="card" id="vizCard">
        <div class="schematic" id="schematic"></div>
        <div class="plotCard">
          <div id="results" class="eq mono"></div>
          <div id="numeric" class="hint" style="margin:6px 0 10px"></div>
          <div id="plot"></div>
        </div>
      </section>
    </div>
  </div>

<script>
  // ---------- Utilities ----------
  const $ = sel => document.querySelector(sel);
  const fmt = d3.format(".4~f");
  const deg2rad = d => d*Math.PI/180;

  function inertiaTriangleAboutCentroidParallelBase(b,a){
    // I_G about centroid for axis parallel to base (through centroid)
    return (b*Math.pow(a,3))/36; // m^4
  }

  function compute(href, a, b, w, thetaDeg, rho, g, refEdge){
    const theta = deg2rad(thetaDeg);
    const A_face = 0.5*a*b;         // m^2 (triangle face)
    const A = A_face * w;           // m^3 projected area into page

    // along-plane distances from top edge to centroid (ybar), and vertical depth to centroid (hC)
    let ybar, hC; // ybar along the plane from top edge; hC vertical depth to centroid

    if(refEdge === 'top'){
      // top edge vertical depth known = href
      ybar = a/3; // centroid is a/3 from the top edge *if base is at top*; BUT for the usual triangle with base at bottom, centroid from TOP is 2a/3
      // adopt the common classroom convention: base at top (per your notes that used y_c = href/sinθ - a/3)
      // To also support the alternate convention swap line below to (2*a/3)
      ybar = a/3;
      hC = href + ybar*Math.sin(theta);
    } else {
      // base edge vertical depth known = href
      const yFromBaseToCentroid = a/3; // centroid from base
      // distance from top edge to centroid = a - a/3 = 2a/3
      ybar = 2*a/3;
      // base depth to top edge along plane is 'a'; vertical step from base edge up to centroid is -yFromBaseToCentroid*sinθ
      hC = href - yFromBaseToCentroid*Math.sin(theta);
    }

    const IG = inertiaTriangleAboutCentroidParallelBase(b,a) * w; // multiply by width into page (parallel axis in 3D prism → I per unit width × w)

    // Hydrostatic resultant (magnitude) and center of pressure depth
    const FR = rho*g*A_face*hC; // N (pressure resultant on the triangular face of width w cancels; A_face is area, pressure integrated times width w → using standard formula)
    const hP = hC + (IG*Math.pow(Math.sin(theta),2)) / (A_face*hC); // vertical depth to center of pressure

    // in-plane offset from centroid to CP along the plane direction (positive downward along the plane)
    const yDiff = (IG*Math.pow(Math.sin(theta),2)) / (A_face*ybar); // (y_R - y_C)

    // x-offset (for a symmetric triangle about midplane → 0). If user rotates triangle in-plane this would change; keep 0 here.
    const xDiff = 0;

    return {A_face, IG, FR, hC, hP, yDiff, xDiff, ybar};
  }

  // ---------- Schematic ----------
  const schW = 360, schH = 220;
  const svg = d3.select('#schematic').append('svg')
    .attr('viewBox', `0 0 ${schW} ${schH}`)
    .attr('role','img')
    .attr('aria-label','Triangle schematic with a and a/3 labels on the left side');

  const gSch = svg.append('g').attr('transform','translate(20,10)');

  function drawSchematic(){
    gSch.selectAll('*').remove();
    const a = +$('#a').value;
    const b = +$('#b').value;
    const theta = +$('#theta').value;

    // scale to fit
    const maxA = 2*Math.max(a,b);
    const sx = d3.scaleLinear().domain([0, Math.max(1, maxA)]).range([0, 260]);
    const sy = d3.scaleLinear().domain([0, Math.max(1, maxA)]).range([0, 160]);

    // triangle with base at top (per note to move a and a/3 to left side)
    const top = {x: 60, y: 10};
    const baseL = {x: top.x - sx(b)/2, y: top.y + sy(a)};
    const baseR = {x: top.x + sx(b)/2, y: top.y + sy(a)};

    const tri = [ [top.x, top.y], [baseL.x, baseL.y], [baseR.x, baseR.y] ];

    gSch.append('polygon')
      .attr('points', tri.map(p=>p.join(',')).join(' '))
      .attr('fill', 'none')
      .attr('stroke', '#93c5fd')
      .attr('stroke-width', 2);

    // Depth arrow (vertical)
    gSch.append('line')
      .attr('x1', top.x - 30).attr('y1', top.y)
      .attr('x2', top.x - 30).attr('y2', baseL.y)
      .attr('stroke', '#64748b').attr('stroke-width', 1.6)
      .attr('marker-end', 'url(#arrow)');

    // a label on left
    gSch.append('path')
      .attr('d', `M ${top.x-10},${top.y} L ${top.x-10},${baseL.y}`)
      .attr('stroke', '#94a3b8').attr('stroke-dasharray','4 3');

    gSch.append('text')
      .attr('x', top.x-18).attr('y', (top.y+baseL.y)/2 - 6)
      .attr('text-anchor','end').attr('font-size', 12).attr('fill', '#cbd5e1')
      .text('a');

    // a/3 tick on left
    const yA3 = top.y + (baseL.y-top.y)/3;
    gSch.append('path').attr('d', `M ${top.x-18},${yA3} h -16`)
      .attr('stroke','#94a3b8');
    gSch.append('text')
      .attr('x', top.x-38).attr('y', yA3-4)
      .attr('text-anchor','end').attr('font-size', 12).attr('fill', '#cbd5e1')
      .text('a/3');

    // theta arc (small)
    gSch.append('path')
      .attr('d', d3.arc()({
        innerRadius: 0, outerRadius: 16, startAngle: -Math.PI/2, endAngle: -Math.PI/2 + deg2rad(theta)
      }))
      .attr('transform', `translate(${top.x+90},${top.y+10})`)
      .attr('fill', 'rgba(96,165,250,.35)');
    gSch.append('text')
      .attr('x', top.x+90+20).attr('y', top.y+10-6)
      .attr('font-size', 12).attr('fill', '#cbd5e1')
      .text('θ');

    // marker for depth reference edge label
    gSch.append('text')
      .attr('x', top.x-32).attr('y', top.y-6)
      .attr('font-size', 11).attr('fill','#94a3b8')
      .text($('#refEdge').value === 'top' ? 'top edge' : 'base edge');
  }

  // Arrowhead marker
  const defs = svg.append('defs');
  defs.append('marker')
    .attr('id','arrow').attr('markerWidth',6).attr('markerHeight',6)
    .attr('refX',5).attr('refY',3)
    .attr('orient','auto')
    .append('path').attr('d','M0,0 L0,6 L6,3 z').attr('fill','#64748b');

  // ---------- Plot ----------
  const plotW = 720, plotH = 320, m = {t:16,r:22,b:44,l:56};
  const svgPlot = d3.select('#plot').append('svg')
    .attr('viewBox',`0 0 ${plotW} ${plotH}`);
  const gPlot = svgPlot.append('g').attr('transform',`translate(${m.l},${m.t})`);
  const innerW = plotW - m.l - m.r, innerH = plotH - m.t - m.b;
  const x = d3.scaleLinear().range([0, innerW]);
  const y = d3.scaleLinear().range([innerH, 0]);
  const xAxisG = gPlot.append('g').attr('transform',`translate(0,${innerH})`);
  const yAxisG = gPlot.append('g');
  const lineX = d3.line().x(d=>x(d.h)).y(d=>y(d.xd));
  const lineY = d3.line().x(d=>x(d.h)).y(d=>y(d.yd));
  const pathX = gPlot.append('path').attr('fill','none').attr('stroke-width',2);
  const pathY = gPlot.append('path').attr('fill','none').attr('stroke-width',2);
  const legend = svgPlot.append('g').attr('transform',`translate(${plotW-210},14)`);

  function renderPlot(params){
    const {a,b,w,theta,rho,g,refEdge} = params;
    const xmax = Math.max(0.5, +$('#xmax').value);
    x.domain([0, xmax]);

    // generate data sweep of depth of reference edge (href)
    const N = 120;
    const hs = d3.range(N).map(i => xmax*i/(N-1));

    const data = hs.map(href => {
      // Avoid divide-by-zero at exactly 0 depth for CP; nudge depth
      const hrefSafe = href <= 0 ? 1e-6 : href;
      const {yDiff, xDiff} = compute(hrefSafe, a,b,w,theta,rho,g,refEdge);
      return {h: href, xd: xDiff, yd: yDiff};
    });

    const yAbsMax = d3.max(data, d => Math.max(Math.abs(d.xd), Math.abs(d.yd))) || 1;
    y.domain([ -yAbsMax*1.1, yAbsMax*1.1 ]);

    xAxisG.call(d3.axisBottom(x));
    yAxisG.call(d3.axisLeft(y));

    pathX.datum(data).attr('d', lineX).attr('stroke', '#f59e0b'); // amber-ish
    pathY.datum(data).attr('d', lineY).attr('stroke', '#60a5fa'); // blue-ish

    // Labels with TeX
    // Clear old
    legend.selectAll('*').remove();
    const row = legend.append('g');
    row.append('rect').attr('x',0).attr('y',0).attr('rx',10).attr('ry',10)
      .attr('width',200).attr('height',46).attr('fill','rgba(255,255,255,.05)').attr('stroke','rgba(255,255,255,.1)');
    row.append('line').attr('x1',12).attr('y1',16).attr('x2',36).attr('y2',16).attr('stroke','#f59e0b').attr('stroke-width',3);
    row.append('foreignObject').attr('x',44).attr('y',6).attr('width',150).attr('height',22)
      .html(`<div xmlns="http://www.w3.org/1999/xhtml" class="mono">$ (x_R - x_C) $</div>`);
    row.append('line').attr('x1',12).attr('y1',34).attr('x2',36).attr('y2',34).attr('stroke','#60a5fa').attr('stroke-width',3);
    row.append('foreignObject').attr('x',44).attr('y',24).attr('width',150).attr('height',22)
      .html(`<div xmlns="http://www.w3.org/1999/xhtml" class="mono">$ (y_R - y_C) $</div>`);

    // axis titles
    svgPlot.selectAll('.xlabel').data([0]).join('foreignObject')
      .attr('class','xlabel').attr('x', m.l + innerW/2 - 80).attr('y', plotH - 28)
      .attr('width',160).attr('height',24)
      .html(`<div xmlns="http://www.w3.org/1999/xhtml" class="mono" style="text-align:center">$h_{\\text{ref}}$ (m)</div>`);

    svgPlot.selectAll('.ylabel').data([0]).join('foreignObject')
      .attr('class','ylabel').attr('x', 4).attr('y', m.t + innerH/2 - 14)
      .attr('width',120).attr('height',28)
      .html(`<div xmlns="http://www.w3.org/1999/xhtml" class="mono" style="transform:rotate(-90deg);transform-origin:left top">$\\Delta$ position (m)</div>`);

    if(window.MathJax){ MathJax.typesetPromise([svgPlot.node()]); }
  }

  // ---------- Results / LaTeX block ----------
  let typesetTimer = null;
  function updateAll(e){
    const a = +$('#a').value;
    const b = +$('#b').value;
    const theta = +$('#theta').value;
    const w = +$('#w').value;
    const rho = +$('#rho').value;
    const g = +$('#g').value;
    const href = +$('#href').value;
    const refEdge = $('#refEdge').value;

    const res = compute(href, a,b,w,theta,rho,g,refEdge);

    // Numeric line (always live)
    $('#numeric').textContent = `A= ${fmt(res.A_face)} m², IG= ${fmt(res.IG)} m⁴, hC= ${fmt(res.hC)} m, hP= ${fmt(res.hP)} m, FR= ${fmt(res.FR)} N, (xR-xC)= ${fmt(res.xDiff)} m, (yR-yC)= ${fmt(res.yDiff)} m`;

    // LaTeX block (optionally only on release)
    const eqHTML = `
      <div>$A = \tfrac{1}{2}\,ab = ${fmt(res.A_face)}\;\text{m}^2$</div>
      <div>$I_G = \dfrac{b a^3}{36} \cdot w = ${fmt(res.IG)}\;\text{m}^4$</div>
      <div>$h_C = h_{\text{ref}} + y_\bar{\ }\,\sin\theta = ${fmt(res.hC)}\;\text{m}$ \;\; (y_\bar{\ } = ${fmt(res.ybar)}\,\text{m})</div>
      <div>$F_R = \rho g A h_C = ${fmt(res.FR)}\;\text{N}$</div>
      <div>$h_P = h_C + \dfrac{I_G\,\sin^2\!\theta}{A\,h_C} = ${fmt(res.hP)}\;\text{m}$</div>
      <div>$y_R - y_C = \dfrac{I_G\,\sin^2\!\theta}{A\,y_\bar{\ }} = ${fmt(res.yDiff)}\;\text{m},\quad x_R - x_C = 0$</div>
    `;

    const mode = $('#updateMode').value;
    if(mode === 'instant' || (e && (e.type==='change' || e.type==='pointerup'))){
      $('#results').innerHTML = eqHTML;
      if(window.MathJax){
        clearTimeout(typesetTimer);
        typesetTimer = setTimeout(()=> MathJax.typesetPromise([$('#vizCard')]), 10);
      }
    } else {
      // numbers update only; LaTeX waits until release
    }

    drawSchematic();
    renderPlot({a,b,w,theta,rho,g,refEdge});
  }

  // ---------- Wiring ----------
  const inputs = ['#a','#b','#theta','#w','#rho','#g','#href','#refEdge','#xmax','#updateMode'];
  inputs.forEach(sel => {
    const el = $(sel);
    el.addEventListener('input', updateAll);
    el.addEventListener('change', updateAll);
    el.addEventListener('pointerup', updateAll);
  });

  $('#refEdge').addEventListener('change', e => {
    const top = e.target.value === 'top';
    $('#refLabel').textContent = top ? 'Top edge depth' : 'Base edge depth';
    updateAll();
  });

  // Initial render
  drawSchematic();
  updateAll({type:'change'});
</script>
</body>
</html>
