<!-- /me310/2.32.html -->
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Constant-Pressure Surfaces in a Liquid Undergoing Rigid-Body Rotation</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <link rel="stylesheet" href="../styles.css" />
  <script src="https://d3js.org/d3.v7.min.js"></script>

  <!-- MathJax -->
  <script>
    window.MathJax = { chtml:{scale:0.9}, options:{renderActions:{addMenu:[]}} };
  </script>
  <script defer src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>

  <style>
    .site-header .container{padding-top:20px;padding-bottom:20px}
    .header-row{display:flex;align-items:center;justify-content:space-between;gap:14px;flex-wrap:wrap}
    .btn{display:inline-flex;align-items:center;gap:8px;padding:10px 14px;border-radius:10px;border:1px solid #ffffff55;
         background:rgba(255,255,255,.12);color:#fff;text-decoration:none}
    .btn.primary{background:var(--accent);border-color:transparent}
    .btn.primary:hover{filter:brightness(1.06)}

    .top-grid{display:grid;gap:14px}
    @media (min-width:1040px){
      .top-grid{grid-template-columns:1.4fr 1fr}
    }

    .side-col{display:flex;flex-direction:column;gap:12px}

    .eqwrap{margin-bottom:10px}
    .eqwrap p{margin:4px 0}
    .note{font-size:14px;color:#4b5563}

    .inputs .controls{display:grid;gap:10px}
    .inputs .ctl{display:flex;flex-direction:column;gap:4px}
    .inputs label{font-size:13px;color:#4b5563}
    .inputs input[type="number"]{
      width:180px;max-width:100%;padding:6px 8px;
      border:1px solid var(--line);border-radius:8px;
    }

    .schematic-card p{margin:0;font-size:14px;color:#4b5563}

    .plots-grid{
      display:grid;gap:14px;
      grid-template-columns:repeat(auto-fit,minmax(260px,1fr));
      margin-top:14px;
    }

    .viz{background:#fff;border:1px solid var(--line);border-radius:12px;padding:8px}
    #plot-omega,#plot-radius,#plot-depth{width:100%;height:auto;display:block}

    .legend-block{margin-top:10px}
    .legend-row{margin-bottom:6px}
    .legend-item{display:inline-flex;align-items:center;gap:6px;margin-right:12px;font-size:13px;color:#334155}
    .legend-item .sw{display:inline-block;width:14px;height:14px;border-radius:3px;border:1px solid #0002}

    .legend-block .dim-note{font-size:13px;color:#6b7280;margin:0;line-height:1.4}

    .back-row{display:flex;align-items:center;margin:12px 0 14px}
    .back-home{
      display:inline-flex;align-items:center;gap:6px;
      padding:6px 10px;border:1px solid var(--line);border-radius:999px;
      background:#fff;color:#0ea5e9;text-decoration:none;font-size:14px;
    }
    .back-home:hover{background:#f0f9ff}
    .back-home .chev{font-size:16px;line-height:1}
  </style>
</head>
<body>
  <!-- Header -->
  <header class="site-header">
    <div class="container">
      <div class="header-row">
        <div>
          <h1 style="margin:0">Constant-Pressure Surfaces in a Liquid Undergoing Rigid-Body Rotation</h1>
          <p class="subtitle">Visualize how the free surface shape depends on angular speed, tank radius, and liquid depth.</p>
        </div>
        <a class="btn primary feedback-link" href="../feedback.html" target="_blank" rel="noopener">Send feedback</a>
      </div>
    </div>
  </header>

  <main class="container">
    <nav class="back-row">
      <a href="../index.html" class="back-home" aria-label="Back to home">
        <span class="chev">←</span> Home
      </a>
    </nav>

    <!-- Top section: derivation + schematic + base inputs -->
    <section class="top-grid">
      <!-- Derivation / equations -->
      <div class="card">
        <h2 style="margin:4px 0 8px">Liquid in Rigid-Body Rotation</h2>

        <div class="eqwrap">
          <p class="note">
            Consider a liquid in a container with circular cross section operating in rigid-body rotation
            with angular speed \( \omega \) about the vertical \( z \)-axis.
          </p>
          <p class="note">
            <b>Equation for surfaces of constant pressure</b><br>
            (The free surface is a representative constant-pressure surface of the liquid in rigid-body rotation.)
          </p>
          \[
            z(r) = \frac{\omega^2 r^2}{2g} + \text{constant}.
          \]
          <p class="note">
            The constant in the above equation depends on the setup of the \( z \)-coordinate and is also
            a function of geometry and angular velocity. For a given setup of the \( z \)-coordinate, geometry,
            and angular velocity, different values of this constant correspond to different constant-pressure
            surfaces.
          </p>
        </div>

        <div class="eqwrap">
          <p style="margin:0 0 4px"><b>Constant volume (no spilling)</b></p>
          <p class="note">
            Let the container have radius \( R \) and liquid depth \( H \) when \( \omega = 0 \)
            (so \( H \) is the liquid depth at rest).
            The volume at rest is
          </p>
          \[
            V = \pi R^2 H.
          \]
          <p class="note">
            When rotating at \( \omega \), with the free surface written as
            \[
              h(r) = \frac{\omega^2 r^2}{2g} + h_0,
            \]
            the volume of liquid is
          </p>
          \[
            \begin{aligned}
              V &= \int_0^R 2\pi r\,h(r)\,dr
                 = \int_0^R 2\pi r\left(\frac{\omega^2 r^2}{2g} + h_0\right)dr \\
                &= 2\pi \left[\frac{\omega^2}{2g}\int_0^R r^3\,dr
                             + h_0\int_0^R r\,dr\right] \\
                &= \frac{\pi \omega^2 R^4}{4g} + \pi R^2 h_0.
            \end{aligned}
          \]
          <p class="note">
            Equating the two expressions for \( V \) gives
          </p>
          \[
            \pi R^2 H
              = \frac{\pi \omega^2 R^4}{4g} + \pi R^2 h_0
              \quad\Rightarrow\quad
              h_0 = H - \frac{\omega^2 R^2}{4g}.
          \]
        </div>

        <div class="eqwrap">
          <p style="margin:0 0 4px"><b>Free-surface equation</b></p>
          <p class="note">
            Substituting \( h_0 \) back into \( h(r) \) gives the free-surface profile
            for a cylindrical container (no spilling):
          </p>
          \[
            z(r) = h(r)
                  = \frac{\omega^2 r^2}{2g}
                    + H - \frac{\omega^2 R^2}{4g}.
          \]
          <p class="note">
            Here \( H \) is the liquid depth when the tank is at rest.
            Different choices of \( \omega \), \( R \), and \( H \) lead to different constant-pressure surfaces.
          </p>
        </div>
      </div>

      <!-- Right column: schematic above inputs -->
      <div class="side-col">

        <div class="card schematic-card">
          <h2 style="margin:4px 0 8px">Schematic (placeholder)</h2>
          <p>
            Vertical cylindrical container of radius \( R \) rotating at angular speed \( \omega \).
            The bottom is at \( z = 0 \); the initial liquid depth at rest is \( H \).
          </p>
          <p style="margin-top:6px">
            During rotation, the free surface \( z(r) \) becomes parabolic. The depth at the center is
            \( h_0 = H - \dfrac{\omega^2 R^2}{4g} \), and the elevation at the wall
            is \( z(R) = H + \dfrac{\omega^2 R^2}{4g} \).
          </p>
          <p style="margin-top:6px">
            (Replace this card with a diagram matching the lecture notes.)
          </p>
        </div>

        <div class="card inputs">
          <h2 style="margin:4px 0 10px">Base Case Inputs</h2>
          <div class="controls">
            <div class="ctl">
              <label for="omegaInput">Angular speed \( \omega_{\text{input}} \) (rad/s)</label>
              <input id="omegaInput" type="number" min="0" max="40" step="0.5" value="10">
            </div>
            <div class="ctl">
              <label for="RInput">Cylinder radius \( R_{\text{input}} \) (m)</label>
              <input id="RInput" type="number" min="0.02" max="0.40" step="0.01" value="0.10">
            </div>
            <div class="ctl">
              <label for="HInput">Liquid depth at \( \omega = 0 \), \( H_{\text{input}} \) (m)</label>
              <input id="HInput" type="number" min="0.05" max="0.50" step="0.01" value="0.20">
            </div>
          </div>
          <p class="note" style="margin-top:10px">
            These base values are used to generate three families of free surfaces:
            one varying \( \omega \), one varying \( R \), and one varying \( H \).
          </p>
        </div>

      </div>
    </section>

    <!-- Three plots -->
    <section class="plots-grid">
      <!-- Plot 1: vary omega -->
      <div class="card">
        <h3 style="margin:4px 0 6px">Effect of Angular Speed \( \omega \)</h3>
        <div class="viz">
          <svg id="plot-omega" viewBox="0 0 360 260" aria-label="Free surfaces for different angular speeds"></svg>
        </div>
        <div id="legend-omega" class="legend-block"></div>
      </div>

      <!-- Plot 2: vary R -->
      <div class="card">
        <h3 style="margin:4px 0 6px">Effect of Cylinder Radius \( R \)</h3>
        <div class="viz">
          <svg id="plot-radius" viewBox="0 0 360 260" aria-label="Free surfaces for different radii"></svg>
        </div>
        <div id="legend-radius" class="legend-block"></div>
      </div>

      <!-- Plot 3: vary H -->
      <div class="card">
        <h3 style="margin:4px 0 6px">Effect of Initial Depth \( H \)</h3>
        <div class="viz">
          <svg id="plot-depth" viewBox="0 0 360 260" aria-label="Free surfaces for different depths"></svg>
        </div>
        <div id="legend-depth" class="legend-block"></div>
      </div>
    </section>
  </main>

  <script>
    const g = 9.81;

    function clamp(val, min, max){
      return Math.max(min, Math.min(max, val));
    }

    function makeSurface(omega, R, H, steps){
      const n = steps || 80;
      const h0 = H - (omega*omega*R*R)/(4*g);
      const pts = [];
      for(let i=0;i<=n;i++){
        const r = R * i/n;
        const z = (omega*omega*r*r)/(2*g) + h0;
        pts.push({r,z});
      }
      return {omega,R,H,h0,pts};
    }

    const colors = ['#2563eb','#f97316','#10b981'];

    function buildSurfaces(mode, omega0, R0, H0){
      const surfaces = [];
      if(mode === 'omega'){
        const omegas = [omega0, 0.5*omega0, omega0/3];
        const labels = ['ω₁ = ω_input','ω₂ = ½ ω_input','ω₃ = ⅓ ω_input'];
        omegas.forEach((om,i)=>{
          surfaces.push({
            key:'w'+i,
            label:labels[i],
            color:colors[i],
            surface:makeSurface(om,R0,H0)
          });
        });
      }else if(mode === 'radius'){
        const Rs = [R0, 0.5*R0, R0/3];
        const labels = ['R₁ = R_input','R₂ = ½ R_input','R₃ = ⅓ R_input'];
        Rs.forEach((R,i)=>{
          surfaces.push({
            key:'r'+i,
            label:labels[i],
            color:colors[i],
            surface:makeSurface(omega0,R,H0)
          });
        });
      }else{ // depth
        const Hs = [H0, 1.2*H0, 1.5*H0];
        const labels = ['H₁ = H_input','H₂ = 1.2 H_input','H₃ = 1.5 H_input'];
        Hs.forEach((H,i)=>{
          surfaces.push({
            key:'h'+i,
            label:labels[i],
            color:colors[i],
            surface:makeSurface(omega0,R0,H)
          });
        });
      }
      return surfaces;
    }

    function initPlot(id, mode){
      const svg = d3.select('#'+id);
      const W = 360, Hh = 260;
      const margin = {top:16,right:10,bottom:46,left:64};
      const iw = W - margin.left - margin.right;
      const ih = Hh - margin.top - margin.bottom;

      svg.attr('viewBox',`0 0 ${W} ${Hh}`);

      const gMain = svg.append('g').attr('transform',`translate(${margin.left},${margin.top})`);
      const axesG = gMain.append('g').attr('class','axes');
      const curvesG = gMain.append('g').attr('class','curves');

      const xAxisG = axesG.append('g')
        .attr('class','axis axis--x')
        .attr('transform',`translate(0,${ih})`);
      const yAxisG = axesG.append('g')
        .attr('class','axis axis--y');

      axesG.append('text')
        .attr('class','axis-title')
        .attr('x', iw/2)
        .attr('y', ih + 38) /* slightly lower for spacing */
        .attr('text-anchor','middle')
        .text('r (m)');

      axesG.append('text')
        .attr('class','axis-title')
        .attr('transform',`translate(-50,${ih/2}) rotate(-90)`)
        .attr('text-anchor','middle')
        .text('z (m)');

      const xScale = d3.scaleLinear().range([0,iw]);
      const yScale = d3.scaleLinear().range([ih,0]);

      const line = d3.line()
        .x(d=>xScale(d.r))
        .y(d=>yScale(d.z));

      return {id,mode,svg,gMain,axesG,curvesG,xAxisG,yAxisG,xScale,yScale,line,iw,ih,yDomain:null};
    }

    const plots = {
      omega:  initPlot('plot-omega','omega'),
      radius: initPlot('plot-radius','radius'),
      depth:  initPlot('plot-depth','depth')
    };

    function updateLegend(mode, surfaces){
      const lid =
        mode==='omega'  ? 'legend-omega'  :
        mode==='radius' ? 'legend-radius' :
                          'legend-depth';
      const container = document.getElementById(lid);

      let shortLatex;
      let expl;

      if(mode === 'omega'){
        shortLatex = ['\\omega_1','\\omega_2','\\omega_3'];
        expl = 'R = R_{\\text{input}},\\; H = H_{\\text{input}}. '
             + 'Three free surfaces with '
             + '\\(\\omega_1 = \\omega_{\\text{input}},\\; '
             + '\\omega_2 = \\tfrac{1}{2}\\,\\omega_{\\text{input}},\\; '
             + '\\omega_3 = \\tfrac{1}{3}\\,\\omega_{\\text{input}}\\). '
             + 'All curves use the same radius and initial depth; only the angular speed \\(\\omega\\) changes.';
      }else if(mode === 'radius'){
        shortLatex = ['R_1','R_2','R_3'];
        expl = '\\omega = \\omega_{\\text{input}},\\; H = H_{\\text{input}}. '
             + 'Three free surfaces with '
             + '\\(R_1 = R_{\\text{input}},\\; '
             + 'R_2 = \\tfrac{1}{2} R_{\\text{input}},\\; '
             + 'R_3 = \\tfrac{1}{3} R_{\\text{input}}\\). '
             + 'All curves use the same angular speed and initial depth; only the cylinder radius \\(R\\) changes.';
      }else{
        shortLatex = ['H_1','H_2','H_3'];
        expl = '\\omega = \\omega_{\\text{input}},\\; R = R_{\\text{input}}. '
             + 'Three free surfaces with '
             + '\\(H_1 = H_{\\text{input}},\\; '
             + 'H_2 = 1.2\\,H_{\\text{input}},\\; '
             + 'H_3 = 1.5\\,H_{\\text{input}}\\). '
             + 'All curves use the same angular speed and radius; only the initial liquid depth \\(H\\) changes.';
      }

      const itemsHTML = surfaces.map((s,i)=>
        `<span class="legend-item"><span class="sw" style="background:${s.color}"></span><span>\\(${shortLatex[i]}\\)</span></span>`
      ).join('');

      container.innerHTML =
        `<div class="legend-row">${itemsHTML}</div>` +
        `<p class="dim-note">${expl}</p>`;

      // Ask MathJax to typeset the new legend content if available
      if(window.MathJax && window.MathJax.typesetPromise){
        MathJax.typesetPromise([container]);
      }
    }

    function updatePlot(plot, omega0, R0, H0){
      const surfaces = buildSurfaces(plot.mode, omega0, R0, H0);

      // Find min/max z and max r for this set
      let rMax = 0;
      let zMin = Infinity, zMax = -Infinity;
      surfaces.forEach(s=>{
        const R = s.surface.R;
        if(R > rMax) rMax = R;
        s.surface.pts.forEach(p=>{
          if(p.z < zMin) zMin = p.z;
          if(p.z > zMax) zMax = p.z;
        });
      });
      if(!isFinite(zMin) || !isFinite(zMax)){
        zMin = 0; zMax = 1;
      }

      // x domain always adapts to current max R
      plot.xScale.domain([0, rMax*1.02]);

      // y domain:
      //  - On first draw: pick a range based on data + padding.
      //  - Later: only expand if new curves would go outside the current range.
      if(!plot.yDomain){
        const span0 = (zMax - zMin) || 1;
        const pad0 = 0.05*span0;
        plot.yDomain = [zMin - pad0, zMax + pad0];
      }else{
        let [yMin,yMax] = plot.yDomain;
        let changed = false;
        if(zMin < yMin){ yMin = zMin; changed = true; }
        if(zMax > yMax){ yMax = zMax; changed = true; }
        if(changed){
          const span = (yMax - yMin) || 1;
          const pad = 0.05*span;
          plot.yDomain = [yMin - pad, yMax + pad];
        }
      }

      plot.yScale.domain(plot.yDomain);

      const xAxis = d3.axisBottom(plot.xScale).ticks(5);
      const yAxis = d3.axisLeft(plot.yScale).ticks(5);

      plot.xAxisG.call(xAxis);
      plot.yAxisG.call(yAxis);

      const paths = plot.curvesG.selectAll('path.curve')
        .data(surfaces, d=>d.key);

      paths.enter()
        .append('path')
        .attr('class','curve')
        .attr('fill','none')
        .attr('stroke-width',2.2)
        .merge(paths)
        .attr('stroke',d=>d.color)
        .attr('d',d=>plot.line(d.surface.pts));

      paths.exit().remove();

      updateLegend(plot.mode, surfaces);
    }

    function updateAll(){
      let omega0 = +document.getElementById('omegaInput').value || 0;
      let R0     = +document.getElementById('RInput').value   || 0.1;
      let H0     = +document.getElementById('HInput').value   || 0.2;

      omega0 = clamp(omega0, 0, 40);
      R0     = clamp(R0, 0.02, 0.40);
      H0     = clamp(H0, 0.05, 0.50);

      document.getElementById('omegaInput').value = omega0.toFixed(2);
      document.getElementById('RInput').value     = R0.toFixed(3);
      document.getElementById('HInput').value     = H0.toFixed(3);

      updatePlot(plots.omega,  omega0, R0, H0);
      updatePlot(plots.radius, omega0, R0, H0);
      updatePlot(plots.depth,  omega0, R0, H0);
    }

    ['omegaInput','RInput','HInput'].forEach(id=>{
      document.getElementById(id).addEventListener('input', updateAll);
    });

    window.addEventListener('DOMContentLoaded', ()=>{
      updateAll();
      // Initial typeset for the static equations
      if(window.MathJax && MathJax.typesetPromise){
        MathJax.typesetPromise();
      }
    });
  </script>

  <!-- Feedback context -->
  <script>
    const FEEDBACK = { course: 'ME 310', sim: 'Eq 2.32 Constant-Pressure Surfaces in Rigid-Body Rotation' };
    document.addEventListener('DOMContentLoaded', () => {
      const url = new URL('../feedback.html', location.href);
      if (FEEDBACK.course) url.searchParams.set('course', FEEDBACK.course);
      if (FEEDBACK.sim)    url.searchParams.set('sim',    FEEDBACK.sim);
      document.querySelectorAll('a.feedback-link').forEach(a => {
        a.href = url.toString();
        try { localStorage.setItem('fb_ctx', JSON.stringify(FEEDBACK)); } catch {}
      });
    });
  </script>
</body>
</html>
